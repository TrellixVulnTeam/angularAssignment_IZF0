import { __asyncGenerator, __generator, __await, __awaiter, __read, __values, __assign, __spread } from 'tslib';
import { EntityOp } from '@ngrx/data';
import { createFeatureSelector, createSelector, select, Store, StoreModule } from '@ngrx/store';
import { combineLatest, from } from 'rxjs';
import { map, shareReplay, take, filter } from 'rxjs/operators';
import { Injectable, NgModule, Optional, SkipSelf, Inject } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var defaultStoreKey = 'ngrxDataPagination';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity, State
 */
function Page() { }
if (false) {
    /** @type {?} */
    Page.prototype.state;
    /** @type {?} */
    Page.prototype.data;
    /** @type {?} */
    Page.prototype.done;
}
/** @type {?} */
var observableToPromisePaginationFunction = (/**
 * @template Entity, State
 * @param {?} observableFn
 * @return {?}
 */
function (observableFn) { return (/**
 * @param {?=} prevState
 * @return {?}
 */
function (prevState) {
    return observableFn(prevState).toPromise();
}); });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO fix TS setup for AsyncPageGenerator types
// export type AsyncPageGenerator<Entity> = AsyncGenerator<Entity[], Entity[], any>;
/**
 * @template Entity, State
 * @param {?} paginationFunction
 * @return {?}
 */
function asyncPageGenerator(paginationFunction) {
    return __asyncGenerator(this, arguments, function asyncPageGenerator_1() {
        var page;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // : AsyncGenerator<Entity[], Entity[], any>
                    page = {
                        data: undefined,
                        state: undefined,
                        done: false,
                    };
                    _a.label = 1;
                case 1:
                    if (!true) return [3 /*break*/, 7];
                    return [4 /*yield*/, __await(paginationFunction(page.state))];
                case 2:
                    page = _a.sent();
                    if (!page.done) return [3 /*break*/, 4];
                    return [4 /*yield*/, __await(page.data)];
                case 3: return [2 /*return*/, _a.sent()];
                case 4: return [4 /*yield*/, __await(page.data)];
                case 5: return [4 /*yield*/, _a.sent()];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 7: return [2 /*return*/];
            }
        });
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Entity
 */
var /**
 * @template Entity
 */
PageIterator = /** @class */ (function () {
    function PageIterator(paginationFunction) {
        var _this = this;
        //  AsyncPageGenerator<Entity>;
        this.done = false;
        this.pending = false;
        this[Symbol.asyncIterator] = (/**
         * @return {?}
         */
        function () { return _this.asyncPageGenerator; });
        this.asyncPageGenerator = asyncPageGenerator(paginationFunction);
    }
    /**
     * @return {?}
     */
    PageIterator.prototype.getNextPage = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.pending) {
                            throw new Error('cannot queue pages (yet)');
                        }
                        if (this.done) {
                            throw new Error('This PageIterator is done. Try creating a new one');
                        }
                        this.pending = true;
                        return [4 /*yield*/, this.asyncPageGenerator.next()];
                    case 1:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        this.pending = false;
                        this.done = done;
                        return [2 /*return*/, value];
                }
            });
        });
    };
    return PageIterator;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    PageIterator.prototype.asyncPageGenerator;
    /** @type {?} */
    PageIterator.prototype.done;
    /**
     * @type {?}
     * @private
     */
    PageIterator.prototype.pending;
    /* Skipping unnamed member:
    [Symbol.asyncIterator] = () => this.asyncPageGenerator;*/
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var PaginationActionType = {
    RESET_PAGINATION_STATE: '[mb-Pagination] Reset Pagination State',
    GET_NEXT_PAGE: '[mb-Pagination] Get Next Page',
    GET_NEXT_PAGE_SUCCESS: '[mb-Pagination] Get Next Page Success',
    GET_NEXT_PAGE_EMPTY: '[mb-Pagination] Get Next Page Empty',
    PREV_PAGE: '[mb-Pagination] Prev Page',
    NEXT_PAGE: '[mb-Pagination] Next Page',
};
/** @type {?} */
var T = PaginationActionType;
/**
 * @record
 */
function Action() { }
if (false) {
    /** @type {?} */
    Action.prototype.type;
}
/**
 * @record
 */
function PaginationActionT() { }
if (false) {
    /** @type {?} */
    PaginationActionT.prototype.type;
    /** @type {?} */
    PaginationActionT.prototype.contextId;
}
var ResetPaginationState = /** @class */ (function () {
    function ResetPaginationState(contextId) {
        this.contextId = contextId;
        this.type = T.RESET_PAGINATION_STATE;
    }
    return ResetPaginationState;
}());
if (false) {
    /** @type {?} */
    ResetPaginationState.prototype.type;
    /** @type {?} */
    ResetPaginationState.prototype.contextId;
}
var GetNextPage = /** @class */ (function () {
    function GetNextPage(contextId) {
        this.contextId = contextId;
        this.type = T.GET_NEXT_PAGE;
    }
    return GetNextPage;
}());
if (false) {
    /** @type {?} */
    GetNextPage.prototype.type;
    /** @type {?} */
    GetNextPage.prototype.contextId;
}
var GetNextPageSuccess = /** @class */ (function () {
    function GetNextPageSuccess(contextId, entityIds, done) {
        this.contextId = contextId;
        this.entityIds = entityIds;
        this.done = done;
        this.type = T.GET_NEXT_PAGE_SUCCESS;
    }
    return GetNextPageSuccess;
}());
if (false) {
    /** @type {?} */
    GetNextPageSuccess.prototype.type;
    /** @type {?} */
    GetNextPageSuccess.prototype.contextId;
    /** @type {?} */
    GetNextPageSuccess.prototype.entityIds;
    /** @type {?} */
    GetNextPageSuccess.prototype.done;
}
var GetNextPageEmpty = /** @class */ (function () {
    function GetNextPageEmpty(contextId) {
        this.contextId = contextId;
        this.type = T.GET_NEXT_PAGE_EMPTY;
    }
    return GetNextPageEmpty;
}());
if (false) {
    /** @type {?} */
    GetNextPageEmpty.prototype.type;
    /** @type {?} */
    GetNextPageEmpty.prototype.contextId;
}
var PrevPage = /** @class */ (function () {
    function PrevPage(contextId) {
        this.contextId = contextId;
        this.type = T.PREV_PAGE;
    }
    return PrevPage;
}());
if (false) {
    /** @type {?} */
    PrevPage.prototype.type;
    /** @type {?} */
    PrevPage.prototype.contextId;
}
var NextPage = /** @class */ (function () {
    function NextPage(contextId) {
        this.contextId = contextId;
        this.type = T.NEXT_PAGE;
    }
    return NextPage;
}());
if (false) {
    /** @type {?} */
    NextPage.prototype.type;
    /** @type {?} */
    NextPage.prototype.contextId;
}
/** @type {?} */
var makeActionCreators = (/**
 * @param {?} contextId
 * @return {?}
 */
function (contextId) { return ({
    ResetPaginationState: (/**
     * @return {?}
     */
    function () { return new ResetPaginationState(contextId); }),
    GetNextPage: (/**
     * @return {?}
     */
    function () { return new GetNextPage(contextId); }),
    GetNextPageSuccess: (/**
     * @param {?} entityIds
     * @param {?} done
     * @return {?}
     */
    function (entityIds, done) {
        return new GetNextPageSuccess(contextId, entityIds, done);
    }),
    GetNextPageEmpty: (/**
     * @return {?}
     */
    function () { return new GetNextPageEmpty(contextId); }),
    PrevPage: (/**
     * @return {?}
     */
    function () { return new PrevPage(contextId); }),
    NextPage: (/**
     * @return {?}
     */
    function () { return new NextPage(contextId); }),
}); });
/** @type {?} */
var makeDispatchers = (/**
 * @param {?} contextId
 * @param {?} dispatch
 * @return {?}
 */
function (contextId, dispatch) {
    /** @type {?} */
    var actionCreators = makeActionCreators(contextId);
    return {
        ResetPaginationState: (/**
         * @return {?}
         */
        function () { return dispatch(actionCreators.ResetPaginationState()); }),
        GetNextPage: (/**
         * @return {?}
         */
        function () { return dispatch(actionCreators.GetNextPage()); }),
        GetNextPageSuccess: (/**
         * @param {?} entityIds
         * @param {?} done
         * @return {?}
         */
        function (entityIds, done) {
            return dispatch(actionCreators.GetNextPageSuccess(entityIds, done));
        }),
        GetNextPageEmpty: (/**
         * @return {?}
         */
        function () { return dispatch(actionCreators.GetNextPageEmpty()); }),
        PrevPage: (/**
         * @return {?}
         */
        function () { return dispatch(actionCreators.PrevPage()); }),
        NextPage: (/**
         * @return {?}
         */
        function () { return dispatch(actionCreators.NextPage()); }),
    };
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var finalPageIndex = (/**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var done = _a.done, pages = _a.pages;
    if (!done || !pages || !pages.length) {
        return null;
    }
    return pages.length - 1;
});
var ɵ0 = finalPageIndex;
/** @type {?} */
var flatten = (/**
 * @template A
 * @param {?} arrays
 * @return {?}
 */
function (arrays) { return arrays.reduce((/**
 * @param {?} result
 * @param {?} as
 * @return {?}
 */
function (result, as) { return result.concat(as); })); });
var ɵ1 = flatten;
var ɵ2 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var pages = _a.pages, currentPage = _a.currentPage;
    return (pages ? pages[currentPage] : null);
}, ɵ3 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var pages = _a.pages;
    return flatten(pages);
}, ɵ4 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var pages = _a.pages;
    return pages;
}, ɵ5 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var pages = _a.pages, currentPage = _a.currentPage;
    return !!pages[currentPage + 1];
}, ɵ6 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var pages = _a.pages, currentPage = _a.currentPage, loadingNewPage = _a.loadingNewPage;
    if (!Number.isInteger(currentPage)) {
        return loadingNewPage;
    }
    return !pages[currentPage + 1] && loadingNewPage;
}, ɵ7 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var loadingNewPage = _a.loadingNewPage;
    return loadingNewPage;
}, ɵ8 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var currentPage = _a.currentPage;
    return currentPage >= 0 ? currentPage : null;
}, ɵ9 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var done = _a.done;
    return done;
}, ɵ10 = /**
 * @param {?} __0
 * @return {?}
 */
function (_a) {
    var currentPage = _a.currentPage;
    return currentPage === 0;
}, ɵ11 = /**
 * @param {?} state
 * @return {?}
 */
function (state) {
    var currentPage = state.currentPage;
    /** @type {?} */
    var finalIndex = finalPageIndex(state);
    if (typeof finalIndex !== 'number' || typeof currentPage !== 'number') {
        return false;
    }
    return currentPage === finalIndex;
};
/** @type {?} */
var contextSelectors = {
    currentPageIds: (ɵ2),
    allIds: (ɵ3),
    allPageIds: (ɵ4),
    nextPageLoaded: (ɵ5),
    nextPageLoading: (ɵ6),
    loadingNewPage: (ɵ7),
    pageNumber: (ɵ8),
    done: (ɵ9),
    finalPageIndex: finalPageIndex,
    onFirstPage: (ɵ10),
    onFinalPage: (ɵ11),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function PaginationContextState() { }
if (false) {
    /** @type {?} */
    PaginationContextState.prototype.pages;
    /** @type {?} */
    PaginationContextState.prototype.loadingNewPage;
    /** @type {?} */
    PaginationContextState.prototype.currentPage;
    /** @type {?} */
    PaginationContextState.prototype.done;
    /** @type {?} */
    PaginationContextState.prototype.progressionCancelled;
}
/**
 * @record
 */
function PaginationState() { }
if (false) {
    /** @type {?} */
    PaginationState.prototype.contexts;
}
/** @type {?} */
var defaultPaginationContextState = {
    pages: [],
    loadingNewPage: false,
    currentPage: -1,
    done: false,
    progressionCancelled: false,
};
/** @type {?} */
var defaultPaginationState = { contexts: {} };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// assumes paginator reducer is plugged in
/**
 * This is a pagination context usable with Redux, ngrx, or
 * any other similar implementations. It writes to, but does
 * not read from the store. It assumes:
 * 1. `dispatch` dispatches an action to the store
 * 2. TODO this library's reducer has been installed
 * @template Entity
 */
var 
// assumes paginator reducer is plugged in
/**
 * This is a pagination context usable with Redux, ngrx, or
 * any other similar implementations. It writes to, but does
 * not read from the store. It assumes:
 * 1. `dispatch` dispatches an action to the store
 * 2. TODO this library's reducer has been installed
 * @template Entity
 */
StorePaginationContext = /** @class */ (function () {
    function StorePaginationContext(
    // Arbitrary. For now, only use one ReduxLikePaginationContext per contextId
    contextId, 
    // For requesting the pages
    paginationFunction, 
    // Dispatch an action meant for the PaginationReducer
    dispatch, onReceivePage, state$, entityMap$) {
        var _this = this;
        this.onReceivePage = onReceivePage;
        this.contextState = defaultPaginationContextState;
        this[Symbol.asyncIterator] = (/**
         * @return {?}
         */
        function () { return _this.pageIterator[Symbol.asyncIterator]; });
        this.contextState$ = state$.pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            return state ? state.contexts[contextId] : defaultPaginationContextState;
        })));
        this.subscription = this.contextState$.subscribe((/**
         * @param {?} contextState
         * @return {?}
         */
        function (contextState) {
            _this.contextState = contextState;
        }));
        this.dispatchers = makeDispatchers(contextId, dispatch);
        this.dispatchers.ResetPaginationState();
        this.pageIterator = new PageIterator(paginationFunction);
        this.entityMap$ = entityMap$.pipe(shareReplay(1));
        // wait until next event loop in case of setup time
        setTimeout((/**
         * @return {?}
         */
        function () { return _this.nextPage(); }), 0);
    }
    /**
     * @return {?}
     */
    StorePaginationContext.prototype.getNextPageP = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var nextPageLoaded, page, entityIds;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nextPageLoaded = contextSelectors.nextPageLoaded(this.contextState);
                        if (nextPageLoaded) {
                            this.incrementCurrentPage();
                            return [2 /*return*/];
                        }
                        if (contextSelectors.done(this.contextState)) {
                            throw new Error('Cannot get more pages after becoming done');
                        }
                        this.dispatchers.GetNextPage();
                        return [4 /*yield*/, this.pageIterator.getNextPage()];
                    case 1:
                        page = _a.sent();
                        this.onReceivePage(page);
                        if (!page) {
                            throw new Error('bad page in getNextPageP');
                        }
                        entityIds = page.map((/**
                         * @param {?} __0
                         * @return {?}
                         */
                        function (_a) {
                            var id = _a.id;
                            return id;
                        }));
                        if (!entityIds.length) {
                            this.dispatchers.GetNextPageEmpty();
                        }
                        else {
                            this.dispatchers.GetNextPageSuccess(entityIds, this.pageIterator.done);
                        }
                        return [2 /*return*/, page];
                }
            });
        });
    };
    /**
     * @return {?}
     */
    StorePaginationContext.prototype.nextPage = /**
     * @return {?}
     */
    function () {
        this.getNextPageP();
    };
    /**
     * @return {?}
     */
    StorePaginationContext.prototype.prevPage = /**
     * @return {?}
     */
    function () {
        if (this.contextState.currentPage <= 0) {
            throw new Error('Cannot go back from page 0');
        }
        this.dispatchers.PrevPage();
    };
    /**
     * @private
     * @return {?}
     */
    StorePaginationContext.prototype.incrementCurrentPage = /**
     * @private
     * @return {?}
     */
    function () {
        this.dispatchers.NextPage();
    };
    Object.defineProperty(StorePaginationContext.prototype, "currentPage$", {
        get: /**
         * @return {?}
         */
        function () {
            return combineLatest(this.entityMap$, this.contextState$).pipe(map((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 2), entityMap = _b[0], contextState = _b[1];
                /** @type {?} */
                var currentPageIds = contextSelectors.currentPageIds(contextState);
                if (!currentPageIds) {
                    return null;
                }
                return currentPageIds.map((/**
                 * @param {?} entityId
                 * @return {?}
                 */
                function (entityId) { return entityMap[entityId]; }));
            })));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    StorePaginationContext.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    return StorePaginationContext;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.pageIterator;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.dispatchers;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.contextState;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.contextState$;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.entityMap$;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.subscription;
    /* Skipping unnamed member:
    [Symbol.asyncIterator] = () => this.pageIterator[Symbol.asyncIterator];*/
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.onReceivePage;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity
 */
function AdvancedSelections() { }
if (false) {
    /** @type {?} */
    AdvancedSelections.prototype.page;
    /** @type {?} */
    AdvancedSelections.prototype.all;
}
/** @type {?} */
var mapValues = (/**
 * @template A
 * @param {?} obj
 * @param {?} f
 * @return {?}
 */
function (obj, f) {
    var e_1, _a;
    /** @type {?} */
    var result = {};
    try {
        for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var k = _c.value;
            result[k] = f(obj[k]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return (/** @type {?} */ (result));
});
var ɵ0$1 = mapValues;
/**
 * Creates pagination selectors that only know about the pagination state
 * @type {?}
 */
var basicPaginationSelectors = (/**
 * @param {?} contextId
 * @return {?}
 */
function (contextId) {
    /** @type {?} */
    var paginationState = createFeatureSelector(defaultStoreKey);
    /** @type {?} */
    var contextState = createSelector(paginationState, (/**
     * @param {?} s
     * @return {?}
     */
    function (s) { return s.contexts[contextId]; }));
    /** @type {?} */
    var contextSelector = (/**
     * @template A
     * @param {?} f
     * @return {?}
     */
    function (f) {
        return createSelector(contextState, f);
    });
    return mapValues(contextSelectors, contextSelector);
});
var ɵ1$1 = basicPaginationSelectors;
/**
 * Creates selectors that know about the entity cache
 * @type {?}
 */
var advancedPaginationSelectors = (/**
 * @template Entity
 * @param {?} basicPaginationSelectors
 * @param {?} selectEntityMap
 * @return {?}
 */
function (basicPaginationSelectors, selectEntityMap) {
    return {
        page: createSelector(basicPaginationSelectors.currentPageIds, selectEntityMap, (/**
         * @param {?} ids
         * @param {?} entityMap
         * @return {?}
         */
        function (ids, entityMap) {
            if (!ids || !entityMap) {
                return null;
            }
            return ids.reduce((/**
             * @param {?} a
             * @param {?} id
             * @return {?}
             */
            function (a, id) {
                if (id in entityMap) {
                    a.push(entityMap[id]);
                }
                return a;
            }), []);
        })),
        all: createSelector(basicPaginationSelectors.allIds, selectEntityMap, (/**
         * @param {?} allIds
         * @param {?} entityMap
         * @return {?}
         */
        function (allIds, entityMap) {
            if (!allIds || !entityMap) {
                return null;
            }
            return allIds.map((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return entityMap[id]; }));
        })),
    };
});
var ɵ2$1 = advancedPaginationSelectors;
/** @type {?} */
var allPaginationSelectors = (/**
 * @template Entity
 * @param {?} contextId
 * @param {?} selectEntityMap
 * @return {?}
 */
function (contextId, selectEntityMap) {
    /** @type {?} */
    var basicSelectors = basicPaginationSelectors(contextId);
    /** @type {?} */
    var advancedSelectors = advancedPaginationSelectors(basicSelectors, selectEntityMap);
    return __assign({}, basicSelectors, advancedSelectors);
});
/** @type {?} */
var allPaginationObservables = (/**
 * @template Entity
 * @param {?} store
 * @param {?} allSelectors
 * @return {?}
 */
function (store, allSelectors) {
    /** @type {?} */
    var sel = (/**
     * @template A
     * @param {?} selector
     * @return {?}
     */
    function (selector) { return store.pipe(select(selector)); });
    return mapValues(allSelectors, sel);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adapts `StorePaginationContext` to work with ngrx/data
 * @template Entity, NextPageState
 */
var  /**
 * Adapts `StorePaginationContext` to work with ngrx/data
 * @template Entity, NextPageState
 */
Pagination = /** @class */ (function () {
    function Pagination(contextId, paginationFunction, entityService, store, ngrxDataPaginationStoreKey, addToCache) {
        var _this = this;
        this.entityService = entityService;
        /** @type {?} */
        var dispatch = (/**
         * @param {?} action
         * @return {?}
         */
        function (action) { return store.dispatch(action); });
        /** @type {?} */
        var onReceivePage = (/**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            if (!addToCache) {
                return;
            }
            _this.entityService.upsertManyInCache(page);
            _this.entityService.createAndDispatch(EntityOp.SAVE_UPSERT_MANY_SUCCESS, page);
        });
        /** @type {?} */
        var paginationState$ = (/** @type {?} */ (store.pipe(select(ngrxDataPaginationStoreKey))));
        /** @type {?} */
        var entityMap$ = entityService.selectors$.entityMap$;
        this.storePaginationContext = new StorePaginationContext(contextId, observableToPromisePaginationFunction(paginationFunction), dispatch, onReceivePage, paginationState$, entityMap$);
        this.selectors = allPaginationSelectors(contextId, entityService.selectors.selectEntityMap);
        this.selectors$ = allPaginationObservables(store, this.selectors);
    }
    /**
     * @return {?}
     */
    Pagination.prototype.nextPage = /**
     * @return {?}
     */
    function () {
        return this.storePaginationContext.nextPage();
    };
    /**
     * @return {?}
     */
    Pagination.prototype.prevPage = /**
     * @return {?}
     */
    function () {
        return this.storePaginationContext.prevPage();
    };
    /** Not yet cancellable! Use with caution. */
    /**
     * Not yet cancellable! Use with caution.
     * @return {?}
     */
    Pagination.prototype._loadAllPages = /**
     * Not yet cancellable! Use with caution.
     * @return {?}
     */
    function () {
        return from(this._loadAllPagesP()).pipe(take(1));
    };
    /**
     * @private
     * @return {?}
     */
    Pagination.prototype._loadAllPagesP = /**
     * @private
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var done;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // wait until not loading
                    return [4 /*yield*/, this.selectors$.nextPageLoading
                            .pipe(filter((/**
                         * @param {?} loading
                         * @return {?}
                         */
                        function (loading) { return !loading; })), take(1))
                            .toPromise()];
                    case 1:
                        // wait until not loading
                        _a.sent();
                        // start the next-page request
                        this.nextPage();
                        // wait until not loading, again
                        return [4 /*yield*/, this.selectors$.nextPageLoading
                                .pipe(filter((/**
                             * @param {?} loading
                             * @return {?}
                             */
                            function (loading) { return !loading; })), take(1))
                                .toPromise()];
                    case 2:
                        // wait until not loading, again
                        _a.sent();
                        return [4 /*yield*/, this.selectors$.done
                                .pipe(take(1))
                                .toPromise()];
                    case 3:
                        done = _a.sent();
                        if (done) {
                            // done case: let the whole function return
                            return [2 /*return*/];
                        }
                        // recursive case: not done, so recurse
                        return [2 /*return*/, this._loadAllPages()];
                }
            });
        });
    };
    return Pagination;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    Pagination.prototype.storePaginationContext;
    /** @type {?} */
    Pagination.prototype.selectors;
    /** @type {?} */
    Pagination.prototype.selectors$;
    /**
     * @type {?}
     * @private
     */
    Pagination.prototype.entityService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity, NextPageState
 */
function PaginationFactoryArgs() { }
if (false) {
    /** @type {?|undefined} */
    PaginationFactoryArgs.prototype.contextId;
    /** @type {?} */
    PaginationFactoryArgs.prototype.paginationFunction;
    /** @type {?} */
    PaginationFactoryArgs.prototype.entityService;
    /** @type {?|undefined} */
    PaginationFactoryArgs.prototype.addToCache;
}
var PaginationFactory = /** @class */ (function () {
    function PaginationFactory(store) {
        this.store = store;
        this.counter = 0;
    }
    /**
     * @template Entity, NextPageState
     * @param {?} __0
     * @return {?}
     */
    PaginationFactory.prototype.create = /**
     * @template Entity, NextPageState
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var entityService = _a.entityService, paginationFunction = _a.paginationFunction, _b = _a.addToCache, addToCache = _b === void 0 ? true : _b, _c = _a.contextId, contextId = _c === void 0 ? entityService.entityName + "-" + this.counter++ : _c;
        return new Pagination(contextId, paginationFunction, entityService, this.store, defaultStoreKey, addToCache);
    };
    PaginationFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    PaginationFactory.ctorParameters = function () { return [
        { type: Store }
    ]; };
    return PaginationFactory;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    PaginationFactory.prototype.counter;
    /**
     * @type {?}
     * @private
     */
    PaginationFactory.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function paginationContextReducer(state, action) {
    if (state === void 0) { state = defaultPaginationContextState; }
    switch (action.type) {
        case PaginationActionType.RESET_PAGINATION_STATE:
            return defaultPaginationContextState;
        case PaginationActionType.GET_NEXT_PAGE:
            return __assign({}, state, { loadingNewPage: true, progressionCancelled: false });
        case PaginationActionType.GET_NEXT_PAGE_SUCCESS:
            return __assign({}, state, { loadingNewPage: false, pages: __spread(state.pages, [action.entityIds]), currentPage: state.progressionCancelled
                    ? state.currentPage
                    : state.currentPage + 1, done: action.done, progressionCancelled: false });
        case PaginationActionType.GET_NEXT_PAGE_EMPTY:
            /** @type {?} */
            var isFirstFetchedPage = (state.pages.length === 0);
            return __assign({}, state, { loadingNewPage: false, pages: isFirstFetchedPage ? [[]] : __spread(state.pages), currentPage: state.progressionCancelled && !isFirstFetchedPage
                    ? state.currentPage
                    : state.currentPage + 1, done: true, progressionCancelled: false });
        case PaginationActionType.PREV_PAGE:
            return __assign({}, state, { currentPage: state.currentPage - 1, progressionCancelled: contextSelectors.nextPageLoading(state) });
        case PaginationActionType.NEXT_PAGE:
            return __assign({}, state, { currentPage: state.currentPage + 1 });
        default:
            return state;
    }
}
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function paginationReducer(state, action) {
    var _a;
    if (state === void 0) { state = defaultPaginationState; }
    if (!action || !action.type.startsWith('[mb-Pagination]')) {
        return state;
    }
    return __assign({}, state, { contexts: __assign({}, state.contexts, (_a = {}, _a[action.contextId] = paginationContextReducer(state.contexts[action.contextId], action), _a)) });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NGRX_DATA_PAGINATION_STORE_KEY = 'NGRX_DATA_PAGINATION_STORE_KEY';
var PaginationModule = /** @class */ (function () {
    function PaginationModule(parentModule, storeKey) {
        if (parentModule) {
            throw new Error('PaginationModule is already loaded. Import it in the root module (usually the AppModule) only');
        }
        if (!storeKey) {
            throw new Error('ngrx-data-pagination requires PaginationModule.forRoot() to be imported');
        }
    }
    /**
     * `storeKey` doesn't actually work yet`
     */
    /**
     * `storeKey` doesn't actually work yet`
     * @return {?}
     */
    PaginationModule.forRoot = /**
     * `storeKey` doesn't actually work yet`
     * @return {?}
     */
    function () {
        return {
            ngModule: PaginationModule,
            providers: [
                {
                    provide: NGRX_DATA_PAGINATION_STORE_KEY,
                    useValue: defaultStoreKey,
                },
            ],
        };
    };
    PaginationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [],
                    imports: [StoreModule.forFeature(defaultStoreKey, paginationReducer)],
                    exports: [],
                    providers: [PaginationFactory],
                },] }
    ];
    /** @nocollapse */
    PaginationModule.ctorParameters = function () { return [
        { type: PaginationModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [NGRX_DATA_PAGINATION_STORE_KEY,] }] }
    ]; };
    return PaginationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { defaultStoreKey as NGRX_DATA_PAGINATION_STORE_KEY, Pagination, PaginationFactory, PaginationModule, paginationReducer };
//# sourceMappingURL=ngrx-data-pagination.js.map
