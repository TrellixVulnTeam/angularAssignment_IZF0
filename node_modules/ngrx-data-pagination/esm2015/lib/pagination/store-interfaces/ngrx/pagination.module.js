/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, NgModule, Optional, SkipSelf, } from '@angular/core';
import { StoreModule } from '@ngrx/store';
import { paginationReducer } from '../../store/reducer';
import { defaultStoreKey } from './default-store-key';
import { PaginationFactory } from './pagination-factory.service';
/** @type {?} */
const NGRX_DATA_PAGINATION_STORE_KEY = 'NGRX_DATA_PAGINATION_STORE_KEY';
export class PaginationModule {
    /**
     * @param {?} parentModule
     * @param {?} storeKey
     */
    constructor(parentModule, storeKey) {
        if (parentModule) {
            throw new Error('PaginationModule is already loaded. Import it in the root module (usually the AppModule) only');
        }
        if (!storeKey) {
            throw new Error('ngrx-data-pagination requires PaginationModule.forRoot() to be imported');
        }
    }
    /**
     * `storeKey` doesn't actually work yet`
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: PaginationModule,
            providers: [
                {
                    provide: NGRX_DATA_PAGINATION_STORE_KEY,
                    useValue: defaultStoreKey,
                },
            ],
        };
    }
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [StoreModule.forFeature(defaultStoreKey, paginationReducer)],
                exports: [],
                providers: [PaginationFactory],
            },] }
];
/** @nocollapse */
PaginationModule.ctorParameters = () => [
    { type: PaginationModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [NGRX_DATA_PAGINATION_STORE_KEY,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5tb2R1bGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3J4LWRhdGEtcGFnaW5hdGlvbi8iLCJzb3VyY2VzIjpbImxpYi9wYWdpbmF0aW9uL3N0b3JlLWludGVyZmFjZXMvbmdyeC9wYWdpbmF0aW9uLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLE1BQU0sRUFFTixRQUFRLEVBQ1IsUUFBUSxFQUNSLFFBQVEsR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7TUFFM0QsOEJBQThCLEdBQUcsZ0NBQWdDO0FBUXZFLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7O0lBQzNCLFlBQzBCLFlBQThCLEVBQ0YsUUFBZ0I7UUFFcEUsSUFBSSxZQUFZLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FDYiwrRkFBK0YsQ0FDaEcsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSxLQUFLLENBQ2IseUVBQXlFLENBQzFFLENBQUM7U0FDSDtJQUNILENBQUM7Ozs7O0lBS0QsTUFBTSxDQUFDLE9BQU87UUFDWixPQUFPO1lBQ0wsUUFBUSxFQUFFLGdCQUFnQjtZQUMxQixTQUFTLEVBQUU7Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLDhCQUE4QjtvQkFDdkMsUUFBUSxFQUFFLGVBQWU7aUJBQzFCO2FBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQzs7O1lBcENGLFFBQVEsU0FBQztnQkFDUixZQUFZLEVBQUUsRUFBRTtnQkFDaEIsT0FBTyxFQUFFLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxlQUFlLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztnQkFDckUsT0FBTyxFQUFFLEVBQUU7Z0JBQ1gsU0FBUyxFQUFFLENBQUMsaUJBQWlCLENBQUM7YUFDL0I7Ozs7WUFHeUMsZ0JBQWdCLHVCQUFyRCxRQUFRLFlBQUksUUFBUTt5Q0FDcEIsUUFBUSxZQUFJLE1BQU0sU0FBQyw4QkFBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBJbmplY3QsXG4gIE1vZHVsZVdpdGhQcm92aWRlcnMsXG4gIE5nTW9kdWxlLFxuICBPcHRpb25hbCxcbiAgU2tpcFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RvcmVNb2R1bGUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBwYWdpbmF0aW9uUmVkdWNlciB9IGZyb20gJy4uLy4uL3N0b3JlL3JlZHVjZXInO1xuaW1wb3J0IHsgZGVmYXVsdFN0b3JlS2V5IH0gZnJvbSAnLi9kZWZhdWx0LXN0b3JlLWtleSc7XG5pbXBvcnQgeyBQYWdpbmF0aW9uRmFjdG9yeSB9IGZyb20gJy4vcGFnaW5hdGlvbi1mYWN0b3J5LnNlcnZpY2UnO1xuXG5jb25zdCBOR1JYX0RBVEFfUEFHSU5BVElPTl9TVE9SRV9LRVkgPSAnTkdSWF9EQVRBX1BBR0lOQVRJT05fU1RPUkVfS0VZJztcblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbXSxcbiAgaW1wb3J0czogW1N0b3JlTW9kdWxlLmZvckZlYXR1cmUoZGVmYXVsdFN0b3JlS2V5LCBwYWdpbmF0aW9uUmVkdWNlcildLFxuICBleHBvcnRzOiBbXSxcbiAgcHJvdmlkZXJzOiBbUGFnaW5hdGlvbkZhY3RvcnldLFxufSlcbmV4cG9ydCBjbGFzcyBQYWdpbmF0aW9uTW9kdWxlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgcGFyZW50TW9kdWxlOiBQYWdpbmF0aW9uTW9kdWxlLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTkdSWF9EQVRBX1BBR0lOQVRJT05fU1RPUkVfS0VZKSBzdG9yZUtleTogc3RyaW5nLFxuICApIHtcbiAgICBpZiAocGFyZW50TW9kdWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdQYWdpbmF0aW9uTW9kdWxlIGlzIGFscmVhZHkgbG9hZGVkLiBJbXBvcnQgaXQgaW4gdGhlIHJvb3QgbW9kdWxlICh1c3VhbGx5IHRoZSBBcHBNb2R1bGUpIG9ubHknLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFzdG9yZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbmdyeC1kYXRhLXBhZ2luYXRpb24gcmVxdWlyZXMgUGFnaW5hdGlvbk1vZHVsZS5mb3JSb290KCkgdG8gYmUgaW1wb3J0ZWQnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYHN0b3JlS2V5YCBkb2Vzbid0IGFjdHVhbGx5IHdvcmsgeWV0YFxuICAgKi9cbiAgc3RhdGljIGZvclJvb3QoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBQYWdpbmF0aW9uTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBOR1JYX0RBVEFfUEFHSU5BVElPTl9TVE9SRV9LRVksXG4gICAgICAgICAgdXNlVmFsdWU6IGRlZmF1bHRTdG9yZUtleSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxufVxuIl19