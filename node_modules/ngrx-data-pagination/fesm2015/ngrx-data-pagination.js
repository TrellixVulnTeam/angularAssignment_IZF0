import { __asyncGenerator, __await, __awaiter } from 'tslib';
import { EntityOp } from '@ngrx/data';
import { createFeatureSelector, createSelector, select, Store, StoreModule } from '@ngrx/store';
import { combineLatest, from } from 'rxjs';
import { map, shareReplay, take, filter } from 'rxjs/operators';
import { Injectable, NgModule, Optional, SkipSelf, Inject } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultStoreKey = 'ngrxDataPagination';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity, State
 */
function Page() { }
if (false) {
    /** @type {?} */
    Page.prototype.state;
    /** @type {?} */
    Page.prototype.data;
    /** @type {?} */
    Page.prototype.done;
}
/** @type {?} */
const observableToPromisePaginationFunction = (/**
 * @template Entity, State
 * @param {?} observableFn
 * @return {?}
 */
(observableFn) => (/**
 * @param {?=} prevState
 * @return {?}
 */
(prevState) => observableFn(prevState).toPromise()));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO fix TS setup for AsyncPageGenerator types
// export type AsyncPageGenerator<Entity> = AsyncGenerator<Entity[], Entity[], any>;
/**
 * @template Entity, State
 * @param {?} paginationFunction
 * @return {?}
 */
function asyncPageGenerator(paginationFunction) {
    return __asyncGenerator(this, arguments, function* asyncPageGenerator_1() {
        // : AsyncGenerator<Entity[], Entity[], any>
        /** @type {?} */
        let page = {
            data: undefined,
            state: undefined,
            done: false,
        };
        while (true) {
            page = yield __await(paginationFunction(page.state));
            if (page.done) {
                return yield __await(page.data);
            }
            yield yield __await(page.data);
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Entity
 */
class PageIterator {
    /**
     * @param {?} paginationFunction
     */
    constructor(paginationFunction) {
        //  AsyncPageGenerator<Entity>;
        this.done = false;
        this.pending = false;
        this[Symbol.asyncIterator] = (/**
         * @return {?}
         */
        () => this.asyncPageGenerator);
        this.asyncPageGenerator = asyncPageGenerator(paginationFunction);
    }
    /**
     * @return {?}
     */
    getNextPage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pending) {
                throw new Error('cannot queue pages (yet)');
            }
            if (this.done) {
                throw new Error('This PageIterator is done. Try creating a new one');
            }
            this.pending = true;
            const { value, done } = yield this.asyncPageGenerator.next();
            this.pending = false;
            this.done = done;
            return value;
        });
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    PageIterator.prototype.asyncPageGenerator;
    /** @type {?} */
    PageIterator.prototype.done;
    /**
     * @type {?}
     * @private
     */
    PageIterator.prototype.pending;
    /* Skipping unnamed member:
    [Symbol.asyncIterator] = () => this.asyncPageGenerator;*/
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const PaginationActionType = {
    RESET_PAGINATION_STATE: '[mb-Pagination] Reset Pagination State',
    GET_NEXT_PAGE: '[mb-Pagination] Get Next Page',
    GET_NEXT_PAGE_SUCCESS: '[mb-Pagination] Get Next Page Success',
    GET_NEXT_PAGE_EMPTY: '[mb-Pagination] Get Next Page Empty',
    PREV_PAGE: '[mb-Pagination] Prev Page',
    NEXT_PAGE: '[mb-Pagination] Next Page',
};
/** @type {?} */
const T = PaginationActionType;
/**
 * @record
 */
function Action() { }
if (false) {
    /** @type {?} */
    Action.prototype.type;
}
/**
 * @record
 */
function PaginationActionT() { }
if (false) {
    /** @type {?} */
    PaginationActionT.prototype.type;
    /** @type {?} */
    PaginationActionT.prototype.contextId;
}
class ResetPaginationState {
    /**
     * @param {?} contextId
     */
    constructor(contextId) {
        this.contextId = contextId;
        this.type = T.RESET_PAGINATION_STATE;
    }
}
if (false) {
    /** @type {?} */
    ResetPaginationState.prototype.type;
    /** @type {?} */
    ResetPaginationState.prototype.contextId;
}
class GetNextPage {
    /**
     * @param {?} contextId
     */
    constructor(contextId) {
        this.contextId = contextId;
        this.type = T.GET_NEXT_PAGE;
    }
}
if (false) {
    /** @type {?} */
    GetNextPage.prototype.type;
    /** @type {?} */
    GetNextPage.prototype.contextId;
}
class GetNextPageSuccess {
    /**
     * @param {?} contextId
     * @param {?} entityIds
     * @param {?} done
     */
    constructor(contextId, entityIds, done) {
        this.contextId = contextId;
        this.entityIds = entityIds;
        this.done = done;
        this.type = T.GET_NEXT_PAGE_SUCCESS;
    }
}
if (false) {
    /** @type {?} */
    GetNextPageSuccess.prototype.type;
    /** @type {?} */
    GetNextPageSuccess.prototype.contextId;
    /** @type {?} */
    GetNextPageSuccess.prototype.entityIds;
    /** @type {?} */
    GetNextPageSuccess.prototype.done;
}
class GetNextPageEmpty {
    /**
     * @param {?} contextId
     */
    constructor(contextId) {
        this.contextId = contextId;
        this.type = T.GET_NEXT_PAGE_EMPTY;
    }
}
if (false) {
    /** @type {?} */
    GetNextPageEmpty.prototype.type;
    /** @type {?} */
    GetNextPageEmpty.prototype.contextId;
}
class PrevPage {
    /**
     * @param {?} contextId
     */
    constructor(contextId) {
        this.contextId = contextId;
        this.type = T.PREV_PAGE;
    }
}
if (false) {
    /** @type {?} */
    PrevPage.prototype.type;
    /** @type {?} */
    PrevPage.prototype.contextId;
}
class NextPage {
    /**
     * @param {?} contextId
     */
    constructor(contextId) {
        this.contextId = contextId;
        this.type = T.NEXT_PAGE;
    }
}
if (false) {
    /** @type {?} */
    NextPage.prototype.type;
    /** @type {?} */
    NextPage.prototype.contextId;
}
/** @type {?} */
const makeActionCreators = (/**
 * @param {?} contextId
 * @return {?}
 */
(contextId) => ({
    ResetPaginationState: (/**
     * @return {?}
     */
    () => new ResetPaginationState(contextId)),
    GetNextPage: (/**
     * @return {?}
     */
    () => new GetNextPage(contextId)),
    GetNextPageSuccess: (/**
     * @param {?} entityIds
     * @param {?} done
     * @return {?}
     */
    (entityIds, done) => new GetNextPageSuccess(contextId, entityIds, done)),
    GetNextPageEmpty: (/**
     * @return {?}
     */
    () => new GetNextPageEmpty(contextId)),
    PrevPage: (/**
     * @return {?}
     */
    () => new PrevPage(contextId)),
    NextPage: (/**
     * @return {?}
     */
    () => new NextPage(contextId)),
}));
/** @type {?} */
const makeDispatchers = (/**
 * @param {?} contextId
 * @param {?} dispatch
 * @return {?}
 */
(contextId, dispatch) => {
    /** @type {?} */
    const actionCreators = makeActionCreators(contextId);
    return {
        ResetPaginationState: (/**
         * @return {?}
         */
        () => dispatch(actionCreators.ResetPaginationState())),
        GetNextPage: (/**
         * @return {?}
         */
        () => dispatch(actionCreators.GetNextPage())),
        GetNextPageSuccess: (/**
         * @param {?} entityIds
         * @param {?} done
         * @return {?}
         */
        (entityIds, done) => dispatch(actionCreators.GetNextPageSuccess(entityIds, done))),
        GetNextPageEmpty: (/**
         * @return {?}
         */
        () => dispatch(actionCreators.GetNextPageEmpty())),
        PrevPage: (/**
         * @return {?}
         */
        () => dispatch(actionCreators.PrevPage())),
        NextPage: (/**
         * @return {?}
         */
        () => dispatch(actionCreators.NextPage())),
    };
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const finalPageIndex = (/**
 * @param {?} __0
 * @return {?}
 */
({ done, pages }) => {
    if (!done || !pages || !pages.length) {
        return null;
    }
    return pages.length - 1;
});
const ɵ0 = finalPageIndex;
/** @type {?} */
const flatten = (/**
 * @template A
 * @param {?} arrays
 * @return {?}
 */
(arrays) => arrays.reduce((/**
 * @param {?} result
 * @param {?} as
 * @return {?}
 */
(result, as) => result.concat(as))));
const ɵ1 = flatten;
const ɵ2 = /**
 * @param {?} __0
 * @return {?}
 */
({ pages, currentPage, }) => (pages ? pages[currentPage] : null), ɵ3 = /**
 * @param {?} __0
 * @return {?}
 */
({ pages }) => flatten(pages), ɵ4 = /**
 * @param {?} __0
 * @return {?}
 */
({ pages }) => pages, ɵ5 = /**
 * @param {?} __0
 * @return {?}
 */
({ pages, currentPage }) => !!pages[currentPage + 1], ɵ6 = /**
 * @param {?} __0
 * @return {?}
 */
({ pages, currentPage, loadingNewPage, }) => {
    if (!Number.isInteger(currentPage)) {
        return loadingNewPage;
    }
    return !pages[currentPage + 1] && loadingNewPage;
}, ɵ7 = /**
 * @param {?} __0
 * @return {?}
 */
({ loadingNewPage }) => loadingNewPage, ɵ8 = /**
 * @param {?} __0
 * @return {?}
 */
({ currentPage }) => currentPage >= 0 ? currentPage : null, ɵ9 = /**
 * @param {?} __0
 * @return {?}
 */
({ done }) => done, ɵ10 = /**
 * @param {?} __0
 * @return {?}
 */
({ currentPage }) => currentPage === 0, ɵ11 = /**
 * @param {?} state
 * @return {?}
 */
(state) => {
    const { currentPage } = state;
    /** @type {?} */
    const finalIndex = finalPageIndex(state);
    if (typeof finalIndex !== 'number' || typeof currentPage !== 'number') {
        return false;
    }
    return currentPage === finalIndex;
};
/** @type {?} */
const contextSelectors = {
    currentPageIds: (ɵ2),
    allIds: (ɵ3),
    allPageIds: (ɵ4),
    nextPageLoaded: (ɵ5),
    nextPageLoading: (ɵ6),
    loadingNewPage: (ɵ7),
    pageNumber: (ɵ8),
    done: (ɵ9),
    finalPageIndex,
    onFirstPage: (ɵ10),
    onFinalPage: (ɵ11),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function PaginationContextState() { }
if (false) {
    /** @type {?} */
    PaginationContextState.prototype.pages;
    /** @type {?} */
    PaginationContextState.prototype.loadingNewPage;
    /** @type {?} */
    PaginationContextState.prototype.currentPage;
    /** @type {?} */
    PaginationContextState.prototype.done;
    /** @type {?} */
    PaginationContextState.prototype.progressionCancelled;
}
/**
 * @record
 */
function PaginationState() { }
if (false) {
    /** @type {?} */
    PaginationState.prototype.contexts;
}
/** @type {?} */
const defaultPaginationContextState = {
    pages: [],
    loadingNewPage: false,
    currentPage: -1,
    done: false,
    progressionCancelled: false,
};
/** @type {?} */
const defaultPaginationState = { contexts: {} };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// assumes paginator reducer is plugged in
/**
 * This is a pagination context usable with Redux, ngrx, or
 * any other similar implementations. It writes to, but does
 * not read from the store. It assumes:
 * 1. `dispatch` dispatches an action to the store
 * 2. TODO this library's reducer has been installed
 * @template Entity
 */
class StorePaginationContext {
    /**
     * @param {?} contextId
     * @param {?} paginationFunction
     * @param {?} dispatch
     * @param {?} onReceivePage
     * @param {?} state$
     * @param {?} entityMap$
     */
    constructor(
    // Arbitrary. For now, only use one ReduxLikePaginationContext per contextId
    contextId, 
    // For requesting the pages
    paginationFunction, 
    // Dispatch an action meant for the PaginationReducer
    dispatch, onReceivePage, state$, entityMap$) {
        this.onReceivePage = onReceivePage;
        this.contextState = defaultPaginationContextState;
        this[Symbol.asyncIterator] = (/**
         * @return {?}
         */
        () => this.pageIterator[Symbol.asyncIterator]);
        this.contextState$ = state$.pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        state => state ? state.contexts[contextId] : defaultPaginationContextState)));
        this.subscription = this.contextState$.subscribe((/**
         * @param {?} contextState
         * @return {?}
         */
        contextState => {
            this.contextState = contextState;
        }));
        this.dispatchers = makeDispatchers(contextId, dispatch);
        this.dispatchers.ResetPaginationState();
        this.pageIterator = new PageIterator(paginationFunction);
        this.entityMap$ = entityMap$.pipe(shareReplay(1));
        // wait until next event loop in case of setup time
        setTimeout((/**
         * @return {?}
         */
        () => this.nextPage()), 0);
    }
    /**
     * @return {?}
     */
    getNextPageP() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const nextPageLoaded = contextSelectors.nextPageLoaded(this.contextState);
            if (nextPageLoaded) {
                this.incrementCurrentPage();
                return;
            }
            if (contextSelectors.done(this.contextState)) {
                throw new Error('Cannot get more pages after becoming done');
            }
            this.dispatchers.GetNextPage();
            /** @type {?} */
            const page = yield this.pageIterator.getNextPage();
            this.onReceivePage(page);
            if (!page) {
                throw new Error('bad page in getNextPageP');
            }
            /** @type {?} */
            const entityIds = page.map((/**
             * @param {?} __0
             * @return {?}
             */
            ({ id }) => id));
            if (!entityIds.length) {
                this.dispatchers.GetNextPageEmpty();
            }
            else {
                this.dispatchers.GetNextPageSuccess(entityIds, this.pageIterator.done);
            }
            return page;
        });
    }
    /**
     * @return {?}
     */
    nextPage() {
        this.getNextPageP();
    }
    /**
     * @return {?}
     */
    prevPage() {
        if (this.contextState.currentPage <= 0) {
            throw new Error('Cannot go back from page 0');
        }
        this.dispatchers.PrevPage();
    }
    /**
     * @private
     * @return {?}
     */
    incrementCurrentPage() {
        this.dispatchers.NextPage();
    }
    /**
     * @return {?}
     */
    get currentPage$() {
        return combineLatest(this.entityMap$, this.contextState$).pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([entityMap, contextState]) => {
            /** @type {?} */
            const currentPageIds = contextSelectors.currentPageIds(contextState);
            if (!currentPageIds) {
                return null;
            }
            return currentPageIds.map((/**
             * @param {?} entityId
             * @return {?}
             */
            entityId => entityMap[entityId]));
        })));
    }
    /**
     * @return {?}
     */
    destroy() {
        this.subscription.unsubscribe();
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.pageIterator;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.dispatchers;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.contextState;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.contextState$;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.entityMap$;
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.subscription;
    /* Skipping unnamed member:
    [Symbol.asyncIterator] = () => this.pageIterator[Symbol.asyncIterator];*/
    /**
     * @type {?}
     * @private
     */
    StorePaginationContext.prototype.onReceivePage;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity
 */
function AdvancedSelections() { }
if (false) {
    /** @type {?} */
    AdvancedSelections.prototype.page;
    /** @type {?} */
    AdvancedSelections.prototype.all;
}
/** @type {?} */
const mapValues = (/**
 * @template A
 * @param {?} obj
 * @param {?} f
 * @return {?}
 */
(obj, f) => {
    /** @type {?} */
    const result = {};
    for (const k of Object.keys(obj)) {
        result[k] = f(obj[k]);
    }
    return (/** @type {?} */ (result));
});
const ɵ0$1 = mapValues;
/**
 * Creates pagination selectors that only know about the pagination state
 * @type {?}
 */
const basicPaginationSelectors = (/**
 * @param {?} contextId
 * @return {?}
 */
(contextId) => {
    /** @type {?} */
    const paginationState = createFeatureSelector(defaultStoreKey);
    /** @type {?} */
    const contextState = createSelector(paginationState, (/**
     * @param {?} s
     * @return {?}
     */
    s => s.contexts[contextId]));
    /** @type {?} */
    const contextSelector = (/**
     * @template A
     * @param {?} f
     * @return {?}
     */
    (f) => createSelector(contextState, f));
    return mapValues(contextSelectors, contextSelector);
});
const ɵ1$1 = basicPaginationSelectors;
/**
 * Creates selectors that know about the entity cache
 * @type {?}
 */
const advancedPaginationSelectors = (/**
 * @template Entity
 * @param {?} basicPaginationSelectors
 * @param {?} selectEntityMap
 * @return {?}
 */
(basicPaginationSelectors, selectEntityMap) => {
    return {
        page: createSelector(basicPaginationSelectors.currentPageIds, selectEntityMap, (/**
         * @param {?} ids
         * @param {?} entityMap
         * @return {?}
         */
        (ids, entityMap) => {
            if (!ids || !entityMap) {
                return null;
            }
            return ids.reduce((/**
             * @param {?} a
             * @param {?} id
             * @return {?}
             */
            (a, id) => {
                if (id in entityMap) {
                    a.push(entityMap[id]);
                }
                return a;
            }), []);
        })),
        all: createSelector(basicPaginationSelectors.allIds, selectEntityMap, (/**
         * @param {?} allIds
         * @param {?} entityMap
         * @return {?}
         */
        (allIds, entityMap) => {
            if (!allIds || !entityMap) {
                return null;
            }
            return allIds.map((/**
             * @param {?} id
             * @return {?}
             */
            id => entityMap[id]));
        })),
    };
});
const ɵ2$1 = advancedPaginationSelectors;
/** @type {?} */
const allPaginationSelectors = (/**
 * @template Entity
 * @param {?} contextId
 * @param {?} selectEntityMap
 * @return {?}
 */
(contextId, selectEntityMap) => {
    /** @type {?} */
    const basicSelectors = basicPaginationSelectors(contextId);
    /** @type {?} */
    const advancedSelectors = advancedPaginationSelectors(basicSelectors, selectEntityMap);
    return Object.assign({}, basicSelectors, advancedSelectors);
});
/** @type {?} */
const allPaginationObservables = (/**
 * @template Entity
 * @param {?} store
 * @param {?} allSelectors
 * @return {?}
 */
(store, allSelectors) => {
    /** @type {?} */
    const sel = (/**
     * @template A
     * @param {?} selector
     * @return {?}
     */
    (selector) => store.pipe(select(selector)));
    return mapValues(allSelectors, sel);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adapts `StorePaginationContext` to work with ngrx/data
 * @template Entity, NextPageState
 */
class Pagination {
    /**
     * @param {?} contextId
     * @param {?} paginationFunction
     * @param {?} entityService
     * @param {?} store
     * @param {?} ngrxDataPaginationStoreKey
     * @param {?} addToCache
     */
    constructor(contextId, paginationFunction, entityService, store, ngrxDataPaginationStoreKey, addToCache) {
        this.entityService = entityService;
        /** @type {?} */
        const dispatch = (/**
         * @param {?} action
         * @return {?}
         */
        (action) => store.dispatch(action));
        /** @type {?} */
        const onReceivePage = (/**
         * @param {?} page
         * @return {?}
         */
        (page) => {
            if (!addToCache) {
                return;
            }
            this.entityService.upsertManyInCache(page);
            this.entityService.createAndDispatch(EntityOp.SAVE_UPSERT_MANY_SUCCESS, page);
        });
        /** @type {?} */
        const paginationState$ = (/** @type {?} */ (store.pipe(select(ngrxDataPaginationStoreKey))));
        /** @type {?} */
        const entityMap$ = entityService.selectors$.entityMap$;
        this.storePaginationContext = new StorePaginationContext(contextId, observableToPromisePaginationFunction(paginationFunction), dispatch, onReceivePage, paginationState$, entityMap$);
        this.selectors = allPaginationSelectors(contextId, entityService.selectors.selectEntityMap);
        this.selectors$ = allPaginationObservables(store, this.selectors);
    }
    /**
     * @return {?}
     */
    nextPage() {
        return this.storePaginationContext.nextPage();
    }
    /**
     * @return {?}
     */
    prevPage() {
        return this.storePaginationContext.prevPage();
    }
    /**
     * Not yet cancellable! Use with caution.
     * @return {?}
     */
    _loadAllPages() {
        return from(this._loadAllPagesP()).pipe(take(1));
    }
    /**
     * @private
     * @return {?}
     */
    _loadAllPagesP() {
        return __awaiter(this, void 0, void 0, function* () {
            // wait until not loading
            yield this.selectors$.nextPageLoading
                .pipe(filter((/**
             * @param {?} loading
             * @return {?}
             */
            loading => !loading)), take(1))
                .toPromise();
            // start the next-page request
            this.nextPage();
            // wait until not loading, again
            yield this.selectors$.nextPageLoading
                .pipe(filter((/**
             * @param {?} loading
             * @return {?}
             */
            loading => !loading)), take(1))
                .toPromise();
            /** @type {?} */
            const done = yield this.selectors$.done
                .pipe(take(1))
                .toPromise();
            if (done) {
                // done case: let the whole function return
                return;
            }
            // recursive case: not done, so recurse
            return this._loadAllPages();
        });
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    Pagination.prototype.storePaginationContext;
    /** @type {?} */
    Pagination.prototype.selectors;
    /** @type {?} */
    Pagination.prototype.selectors$;
    /**
     * @type {?}
     * @private
     */
    Pagination.prototype.entityService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template Entity, NextPageState
 */
function PaginationFactoryArgs() { }
if (false) {
    /** @type {?|undefined} */
    PaginationFactoryArgs.prototype.contextId;
    /** @type {?} */
    PaginationFactoryArgs.prototype.paginationFunction;
    /** @type {?} */
    PaginationFactoryArgs.prototype.entityService;
    /** @type {?|undefined} */
    PaginationFactoryArgs.prototype.addToCache;
}
class PaginationFactory {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
        this.counter = 0;
    }
    /**
     * @template Entity, NextPageState
     * @param {?} __0
     * @return {?}
     */
    create({ entityService, paginationFunction, addToCache = true, contextId = `${entityService.entityName}-${this.counter++}`, }) {
        return new Pagination(contextId, paginationFunction, entityService, this.store, defaultStoreKey, addToCache);
    }
}
PaginationFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PaginationFactory.ctorParameters = () => [
    { type: Store }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    PaginationFactory.prototype.counter;
    /**
     * @type {?}
     * @private
     */
    PaginationFactory.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function paginationContextReducer(state = defaultPaginationContextState, action) {
    switch (action.type) {
        case PaginationActionType.RESET_PAGINATION_STATE:
            return defaultPaginationContextState;
        case PaginationActionType.GET_NEXT_PAGE:
            return Object.assign({}, state, { loadingNewPage: true, progressionCancelled: false });
        case PaginationActionType.GET_NEXT_PAGE_SUCCESS:
            return Object.assign({}, state, { loadingNewPage: false, pages: [...state.pages, action.entityIds], currentPage: state.progressionCancelled
                    ? state.currentPage
                    : state.currentPage + 1, done: action.done, progressionCancelled: false });
        case PaginationActionType.GET_NEXT_PAGE_EMPTY:
            /** @type {?} */
            const isFirstFetchedPage = (state.pages.length === 0);
            return Object.assign({}, state, { loadingNewPage: false, pages: isFirstFetchedPage ? [[]] : [...state.pages], currentPage: state.progressionCancelled && !isFirstFetchedPage
                    ? state.currentPage
                    : state.currentPage + 1, done: true, progressionCancelled: false });
        case PaginationActionType.PREV_PAGE:
            return Object.assign({}, state, { currentPage: state.currentPage - 1, progressionCancelled: contextSelectors.nextPageLoading(state) });
        case PaginationActionType.NEXT_PAGE:
            return Object.assign({}, state, { currentPage: state.currentPage + 1 });
        default:
            return state;
    }
}
/**
 * @param {?=} state
 * @param {?=} action
 * @return {?}
 */
function paginationReducer(state = defaultPaginationState, action) {
    if (!action || !action.type.startsWith('[mb-Pagination]')) {
        return state;
    }
    return Object.assign({}, state, { contexts: Object.assign({}, state.contexts, { [action.contextId]: paginationContextReducer(state.contexts[action.contextId], action) }) });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGRX_DATA_PAGINATION_STORE_KEY = 'NGRX_DATA_PAGINATION_STORE_KEY';
class PaginationModule {
    /**
     * @param {?} parentModule
     * @param {?} storeKey
     */
    constructor(parentModule, storeKey) {
        if (parentModule) {
            throw new Error('PaginationModule is already loaded. Import it in the root module (usually the AppModule) only');
        }
        if (!storeKey) {
            throw new Error('ngrx-data-pagination requires PaginationModule.forRoot() to be imported');
        }
    }
    /**
     * `storeKey` doesn't actually work yet`
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: PaginationModule,
            providers: [
                {
                    provide: NGRX_DATA_PAGINATION_STORE_KEY,
                    useValue: defaultStoreKey,
                },
            ],
        };
    }
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [StoreModule.forFeature(defaultStoreKey, paginationReducer)],
                exports: [],
                providers: [PaginationFactory],
            },] }
];
/** @nocollapse */
PaginationModule.ctorParameters = () => [
    { type: PaginationModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [NGRX_DATA_PAGINATION_STORE_KEY,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { defaultStoreKey as NGRX_DATA_PAGINATION_STORE_KEY, Pagination, PaginationFactory, PaginationModule, paginationReducer };
//# sourceMappingURL=ngrx-data-pagination.js.map
